{
  "version": 3,
  "sources": ["../src/waterkottecgi.ts"],
  "sourcesContent": ["import axios from 'axios';\r\nimport {\r\n    AdapterError,\r\n    CommonState,\r\n    ILogProvider,\r\n    Login,\r\n    RethrowError,\r\n    TagResponse,\r\n    UnknownTagResponse,\r\n    WaterkotteError,\r\n} from './types';\r\n\r\nexport class WaterkotteCgi {\r\n    private static readonly TAG_RESPONSE_REG_EXP =\r\n        /\\#(?<name>[\\w\\d]+)\\s+(?<status>.*)\\n(?:(?<unknown>\\d+)\\s+(?<value>.?\\d+))?/gm;\r\n    private static readonly LOGIN_REQUEST_REG_EXP = /(?:(?<status>\\-?\\d+)[\\n\\r]+)?(?<message>\\#.*)/gm;\r\n    private readonly cookieName = 'IDALToken';\r\n    private baseUrl: string;\r\n    private cgiUrl: string;\r\n    private maximumTagsPerRequest = 75;\r\n\r\n    constructor(\r\n        private ipAddress: string,\r\n        private log: ILogProvider,\r\n    ) {\r\n        this.baseUrl = `http://${this.ipAddress}/`;\r\n        this.cgiUrl = `${this.baseUrl}cgi/`;\r\n    }\r\n\r\n    async loginAsync(username: string = 'waterkotte', password: string = 'waterkotte'): Promise<Login> {\r\n        const loginUrl = `${this.cgiUrl}login?username=${username}&password=${password}`;\r\n        const cookie = await this.requestAsync(loginUrl, (response) => {\r\n            try {\r\n                this.validateLogInOutResult(response.data);\r\n            } catch (e: unknown) {\r\n                if (!(e instanceof WaterkotteError && e.message === WaterkotteError.RELOGIN_ATTEMPT_MSG)) {\r\n                    throw e;\r\n                }\r\n            }\r\n            const cookie = (response.headers['set-cookie'] as string[])\r\n                ?.find((cookie) => cookie.includes(this.cookieName))\r\n                ?.match(new RegExp(`^${this.cookieName}=(.+?);`))?.[1];\r\n\r\n            if (!cookie) {\r\n                throw new AdapterError(\r\n                    `Unable to login: Could not find login token '${this.cookieName}' - Response: '${response.data}'`,\r\n                );\r\n            }\r\n\r\n            return cookie;\r\n        });\r\n\r\n        return <Login>{ token: cookie };\r\n    }\r\n\r\n    async logoutAsync(): Promise<void> {\r\n        const logoutUrl = `${this.cgiUrl}logout`;\r\n        await this.requestAsync(logoutUrl, (x) => this.validateLogInOutResult(x.data));\r\n    }\r\n\r\n    validateLogInOutResult(response: string): any {\r\n        const extracted = this.extractWaterkotteInformation(response);\r\n        if (extracted instanceof WaterkotteError) {\r\n            throw extracted;\r\n        } else if (extracted && (extracted.code === 1 || extracted.message == WaterkotteError.RELOGIN_ATTEMPT_MSG)) {\r\n            return extracted;\r\n        } else {\r\n            throw new AdapterError(`Unhandled response from heat pump: ${response}`);\r\n        }\r\n    }\r\n\r\n    extractWaterkotteInformation(response: string): { code: number; message: string } | undefined | WaterkotteError {\r\n        const match = String(response).matchAll(WaterkotteCgi.LOGIN_REQUEST_REG_EXP).next()?.value?.groups;\r\n        if (!match) {\r\n            return undefined;\r\n        }\r\n\r\n        const code = match.status != undefined ? Number(match.status) : match.status;\r\n        if (match.message?.startsWith(WaterkotteError.ERROR_INDICATOR)) {\r\n            return new WaterkotteError(match.message, code);\r\n        }\r\n\r\n        return { code: code, message: match.message };\r\n    }\r\n\r\n    async getTagsAsync(tags: CommonState[], login: Login): Promise<TagResponse[]> {\r\n        const tagResponses: TagResponse[] = [];\r\n        for (let i = 0; i < tags.length; i += this.maximumTagsPerRequest) {\r\n            const chunk = tags.slice(i, i + this.maximumTagsPerRequest);\r\n            const record = chunk.reduce(\r\n                (acc, item) => ({ ...acc, [item['Id']]: item }),\r\n                {} as Record<string, CommonState>,\r\n            );\r\n\r\n            const tagUrl = `${this.cgiUrl}readTags?n=${chunk.length + chunk.map((x, i) => `&t${i + 1}=${x.Id}`).join('')}`;\r\n            const response = await this.requestAsync(\r\n                tagUrl,\r\n                (response) => {\r\n                    const waterkotteResponse = this.extractWaterkotteInformation(response.data);\r\n                    if (waterkotteResponse instanceof WaterkotteError) {\r\n                        throw waterkotteResponse;\r\n                    }\r\n\r\n                    return String(response.data).matchAll(WaterkotteCgi.TAG_RESPONSE_REG_EXP);\r\n                },\r\n                login,\r\n            );\r\n\r\n            for (const match of response) {\r\n                const parameter = match.groups;\r\n                if (!parameter) {\r\n                    continue;\r\n                }\r\n\r\n                const ctor = parameter.status != TagResponse.STATUS_OK ? UnknownTagResponse : TagResponse;\r\n\r\n                const state = record[parameter.name];\r\n\r\n                if (!state) {\r\n                    this.log.warn(`Could not match tag resonse for ${parameter.name} to any requested tag`);\r\n                    continue;\r\n                }\r\n\r\n                tagResponses.push(\r\n                    new ctor(\r\n                        {\r\n                            name: parameter.name,\r\n                            value: parameter.value,\r\n                            status: parameter.status,\r\n                            unkown: parameter.unknown,\r\n                        },\r\n                        state,\r\n                    ),\r\n                );\r\n            }\r\n        }\r\n\r\n        return tagResponses;\r\n    }\r\n\r\n    public async requestAsync<TResult>(\r\n        url: string,\r\n        processResponse: (response: axios.AxiosResponse<any, any>) => TResult,\r\n        login?: Login,\r\n    ): Promise<TResult> {\r\n        try {\r\n            const response = await axios.get(url, {\r\n                headers: { Cookie: login ? `${this.cookieName}=${login.token}` : '' },\r\n            });\r\n\r\n            return processResponse(response);\r\n        } catch (e: unknown) {\r\n            // rethrow own errors\r\n            if (e instanceof WaterkotteError || e instanceof AdapterError) {\r\n                throw e;\r\n            }\r\n\r\n            const baseMessage = `Request ${url.includes('password') ? '' : `to '${url}' `}failed: `;\r\n            if (e instanceof Error) {\r\n                throw new RethrowError(e, `${baseMessage}${e.message}`);\r\n            } else {\r\n                throw new AdapterError(`${baseMessage}${String(e)}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* async writeTags(tags: CommonState[], login: Login): Promise<void> {\r\n        if (tags.length > 75) {\r\n            throw new Error(`Maximum amount of tags per request exceeded (${tags.length}/75)`);\r\n        }\r\n        throw new Error(`Not implemented`);\r\n        const record = tags.reduce((acc, item) => ({ ...acc, [item['Id']]: item }), {} as Record<string, CommonState>);\r\n        var tagUrl =\r\n            baseUrl +\r\n            'writeTags?returnValue=true&n=' +\r\n            tags.length +\r\n            tags.map((x, i) => '&t' + (i + 1) + '=' + x.Id).join('');\r\n        const response = await axios.get(tagUrl, {\r\n            headers: { 'User-Agent': 'ioBroker', Cookie: 'IDALToken=' + login.token },\r\n        });\r\n\r\n        if (response.status === 200) {\r\n            for (let match of String(response.data).matchAll(regex)) {\r\n                const parameter = match.groups;\r\n                console.log(`${parameter.name} ${record[parameter.name].Text} = ${parameter.value}`);\r\n                const state = record[parameter.name];\r\n                setOrCreate(\r\n                    '0_userdata.0.Waterkotte.' + state.Path + '.' + state.Id,\r\n                    state.normalizeValue(parameter.value),\r\n                    true,\r\n                    state.getCommonObject(),\r\n                );\r\n            }\r\n        } else {\r\n            log('Axios Status - Requesting locales: ' + response.state, 'warn');\r\n        }\r\n    }*/\r\n}\r\n"],
  "mappings": "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",
  "names": ["cookie", "i", "response", "axios"]
}
