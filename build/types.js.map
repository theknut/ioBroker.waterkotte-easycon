{
  "version": 3,
  "sources": ["../src/types.ts"],
  "sourcesContent": ["interface Path {\r\n    Id: string;\r\n}\r\n\r\nexport enum PathFlavor {\r\n    Id,\r\n    Description,\r\n}\r\n\r\nexport class CommonState implements Path {\r\n    private static readonly ID_PARTS_REGEXP = /(?<qualifier>[a-z])(?<number>\\d+)/gim;\r\n    readonly type: string = 'CommonState';\r\n\r\n    private idParts: { Qualifier: string; Number: number } | undefined = undefined;\r\n\r\n    constructor(\r\n        public readonly Path: string,\r\n        public readonly Id: string,\r\n        public readonly Text: ioBroker.StringOrTranslated,\r\n        public readonly Unit?: string,\r\n        public readonly Readonly: boolean = true,\r\n        public readonly ValueMap: Record<number, ioBroker.StringOrTranslated> = [],\r\n        public readonly Type: ioBroker.CommonType = 'number',\r\n    ) {}\r\n\r\n    getIdParts(): { Qualifier: string; Number: number } {\r\n        if (!this.idParts) {\r\n            this.idParts = this.doGetIdParts(this.Id);\r\n        }\r\n        return this.idParts;\r\n    }\r\n\r\n    protected doGetIdParts(id: string): { Qualifier: string; Number: number } {\r\n        const groups = id.matchAll(CommonState.ID_PARTS_REGEXP)?.next()?.value?.groups;\r\n        if (!groups) {\r\n            throw new AdapterError(`Tag id ${id} format not supported`);\r\n        }\r\n        return { Qualifier: groups.qualifier, Number: Number(groups.number) };\r\n    }\r\n\r\n    getPath(flavor: PathFlavor = PathFlavor.Id, replaceRegExp?: RegExp, language: ioBroker.Languages = 'en'): string {\r\n        let segments: string[] = [this.Path];\r\n\r\n        switch (flavor) {\r\n            case PathFlavor.Id:\r\n                segments.push(this.Id);\r\n                break;\r\n            case PathFlavor.Description:\r\n                let segment = typeof this.Text === 'string' ? this.Text : this.Text[language] ?? this.Text['en'];\r\n                segment = segment.replaceAll('.', '');\r\n                segments.push(segment);\r\n                break;\r\n            default:\r\n                throw new AdapterError(`Unknown path flavor '${flavor}'`);\r\n        }\r\n\r\n        if (replaceRegExp) {\r\n            segments = segments.map((segment) => segment.replace(replaceRegExp, '_'));\r\n        }\r\n\r\n        const path = segments.join('.');\r\n        return path;\r\n    }\r\n\r\n    getRole(): string {\r\n        if (this.Unit === '\u00B0C') {\r\n            return 'value.temperature';\r\n        } else if (this.Type === 'boolean') {\r\n            return 'indicator';\r\n        } else {\r\n            return 'value';\r\n        }\r\n    }\r\n\r\n    getCommonObject(): ioBroker.StateCommon {\r\n        const common = <ioBroker.StateCommon>{\r\n            name: this.Text,\r\n            unit: this.Unit,\r\n            type: this.Type,\r\n            read: true,\r\n            role: this.getRole(),\r\n            write: !this.Readonly,\r\n            states: this.ValueMap,\r\n        };\r\n        return common;\r\n    }\r\n\r\n    normalizeValue(value: number): any {\r\n        switch (this.getIdParts().Qualifier) {\r\n            case 'D':\r\n                return this.toBoolean(value);\r\n            case 'A':\r\n                if (this.Unit === 'kWh' || this instanceof HexAnalogState) {\r\n                    throw new AdapterError(\r\n                        'Cannot normalize hex value based on a single value. Use this.normalizeHexValue(any, any) instead.',\r\n                    );\r\n                }\r\n                return Number(value) / 10;\r\n            case 'I':\r\n                if (this.Type === 'boolean') {\r\n                    return this.toBoolean(value);\r\n                } else {\r\n                    return Number(value);\r\n                }\r\n            default:\r\n                throw new AdapterError(`Type ${this.Type} not implemented`);\r\n        }\r\n    }\r\n\r\n    private toBoolean(value: any): boolean {\r\n        let numbericValue: number;\r\n        if (typeof value === 'string') {\r\n            numbericValue = Number(value);\r\n        } else if (typeof value === 'number') {\r\n            numbericValue = value;\r\n        } else if (typeof value === 'boolean') {\r\n            return value;\r\n        } else {\r\n            throw new AdapterError(`Received invalid value type '${value}' for id '${this.Id}'`);\r\n        }\r\n\r\n        if (numbericValue > 1) {\r\n            throw new AdapterError(`Received invalid value '${value}' for id '${this.Id}'`);\r\n        }\r\n\r\n        return numbericValue === 1;\r\n    }\r\n}\r\n\r\nexport class HexAnalogState extends CommonState {\r\n    readonly type: string = 'HexAnalogState';\r\n    constructor(\r\n        path: string,\r\n        public idPrimary: string,\r\n        public idSecondary: string,\r\n        text: ioBroker.StringOrTranslated,\r\n    ) {\r\n        super(path, idPrimary, text, 'kWh', true, [], 'number');\r\n\r\n        if (!this.hasValidIds(idPrimary, idSecondary)) {\r\n            throw new AdapterError(`Only analog values can be hex (${idPrimary}, ${idSecondary})`);\r\n        }\r\n    }\r\n\r\n    private hasValidIds(primaryId: string, secondaryId: string): boolean {\r\n        return this.doGetIdParts(primaryId).Qualifier === 'A' && this.doGetIdParts(secondaryId).Qualifier == 'A';\r\n    }\r\n\r\n    normalizeHexValue(firstValue: number, secondaryValue: number): any {\r\n        if (!firstValue || !secondaryValue) {\r\n            throw new AdapterError(\r\n                `None or only one value was provided, but two are needed to normalize hex value (firstValue: ${firstValue}, secondaryValue: ${secondaryValue})`,\r\n            );\r\n        }\r\n\r\n        const value = ((firstValue << 16) >>> 0) | ((secondaryValue >>> 0) & 65535);\r\n        return Number(this.IEEE754_Hex32ToDez(value, 1));\r\n    }\r\n\r\n    private IEEE754_Hex32ToDez(param1: any, t: any): string {\r\n        const a = param1.toString(16);\r\n        let e, i, n, l, o, r, s, d, g;\r\n        const x = '00000000';\r\n        return (\r\n            (i = x + parseInt(a.substr(0, 2), 16).toString(2)),\r\n            (n = x + parseInt(a.substr(2, 2), 16).toString(2)),\r\n            (l = x + parseInt(a.substr(4, 2), 16).toString(2)),\r\n            (o = x + parseInt(a.substr(6, 2), 16).toString(2)),\r\n            (i = i.substr(i.length - 8, 8)),\r\n            (n = n.substr(n.length - 8, 8)),\r\n            (l = l.substr(l.length - 8, 8)),\r\n            (o = o.substr(o.length - 8, 8)),\r\n            (r = i + n + l + o),\r\n            (s = parseInt(r.charAt(0), 2)),\r\n            (d = parseInt(r.substr(1, 8), 2)),\r\n            (g = parseInt(r.substr(9, 23), 2)),\r\n            (e = (1 - 2 * s) * Math.pow(2, d - 127) * (1 + g / Math.pow(2, 23))),\r\n            e.toFixed(t)\r\n        );\r\n    }\r\n}\r\n\r\nexport class ReadOnlyState extends CommonState {\r\n    readonly type: string = 'ReadOnlyState';\r\n    constructor(\r\n        path: string,\r\n        id: string,\r\n        text: ioBroker.StringOrTranslated,\r\n        unit?: string,\r\n        type: ioBroker.CommonType = 'number',\r\n    ) {\r\n        super(path, id, text, unit, true, [], type);\r\n    }\r\n}\r\n\r\nexport class State extends CommonState {\r\n    readonly type: string = 'State';\r\n    constructor(\r\n        path: string,\r\n        id: string,\r\n        text: ioBroker.StringOrTranslated,\r\n        unit?: string,\r\n        type: ioBroker.CommonType = 'number',\r\n    ) {\r\n        super(path, id, text, unit, false, [], type);\r\n    }\r\n}\r\n\r\nexport class EnumState extends CommonState {\r\n    readonly type: string = 'EnumState';\r\n    constructor(\r\n        path: string,\r\n        id: string,\r\n        text: ioBroker.StringOrTranslated,\r\n        valueMap: Record<number, ioBroker.StringOrTranslated>,\r\n        unit?: string,\r\n    ) {\r\n        super(path, id, text, unit, false, valueMap, 'number');\r\n    }\r\n}\r\n\r\nexport class ReadOnlyEnumState extends CommonState {\r\n    readonly type: string = 'ReadOnlyEnumState';\r\n    constructor(\r\n        path: string,\r\n        id: string,\r\n        text: ioBroker.StringOrTranslated,\r\n        valueMap: Record<number, ioBroker.StringOrTranslated>,\r\n        unit?: string,\r\n    ) {\r\n        super(path, id, text, unit, true, valueMap, 'number');\r\n    }\r\n}\r\n\r\nexport class IndicatorState extends ReadOnlyState {\r\n    readonly type: string = 'Indicator';\r\n    constructor(path: string, id: string, text: ioBroker.StringOrTranslated) {\r\n        super(path, id, text, undefined, 'boolean');\r\n    }\r\n}\r\n\r\nexport type Login = {\r\n    readonly token: string;\r\n};\r\n\r\nexport type TagResponseRecord = {\r\n    readonly name: string;\r\n    readonly status: string;\r\n    readonly value: any;\r\n    readonly unkown: string;\r\n};\r\n\r\nexport class TagResponse {\r\n    static STATUS_OK = 'S_OK';\r\n    constructor(\r\n        public readonly response: TagResponseRecord,\r\n        public readonly state: CommonState,\r\n    ) {}\r\n}\r\n\r\nexport class UnknownTagResponse extends TagResponse {\r\n    constructor(response: TagResponseRecord, state: CommonState) {\r\n        super(response, state);\r\n    }\r\n}\r\n\r\nexport interface ILogProvider {\r\n    debug(message: string | unknown): void;\r\n    warn(message: string | unknown): void;\r\n    error(message: string | unknown): void;\r\n}\r\n\r\nexport class WaterkotteError extends Error {\r\n    static TOO_MANY_USERS = -37;\r\n    static USER_DOES_NOT_EXIST = -49;\r\n    static PASS_DONT_MATCH = -45;\r\n    static LOGIN_REQUIRED = -88;\r\n    static NEED_LOGIN_MSG = '#E_NEED_LOGIN';\r\n    static RELOGIN_ATTEMPT_MSG = '#E_RE-LOGIN_ATTEMPT';\r\n    static ERROR_INDICATOR = '#E_';\r\n\r\n    constructor(\r\n        message: string,\r\n        public code?: number,\r\n    ) {\r\n        super(message);\r\n\r\n        if (code === undefined) {\r\n            switch (message) {\r\n                case WaterkotteError.NEED_LOGIN_MSG:\r\n                    this.code = WaterkotteError.LOGIN_REQUIRED;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class AdapterError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n    }\r\n}\r\n\r\nexport class RethrowError extends AdapterError {\r\n    constructor(\r\n        public innerError: Error,\r\n        message: string = innerError.message,\r\n    ) {\r\n        super(message);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["PathFlavor"]
}
