{
  "version": 3,
  "sources": ["../src/waterkotte.ts"],
  "sourcesContent": ["import axios from 'axios';\r\nimport {\r\n    AdapterError,\r\n    CommonState,\r\n    ILogProvider,\r\n    Login,\r\n    RethrowError,\r\n    TagResponse,\r\n    UnknownTagResponse,\r\n    WaterkotteError,\r\n} from './types';\r\n\r\nexport class WaterkotteCgi {\r\n    private static readonly TAG_RESPONSE_REG_EXP =\r\n        /\\#(?<name>[\\w\\d]+)\\s+(?<status>.*)\\n(?:(?<unknown>\\d+)\\s+(?<value>.?\\d+))?/gm;\r\n    private static readonly LOGIN_REQUEST_REG_EXP = /(?<status>-?\\d+)[\\n\\r]+(?<message>.*)/gm;\r\n    private readonly cookieName = 'IDALToken';\r\n    private baseUrl: string;\r\n    private cgiUrl: string;\r\n    private maximumTagsPerRequest = 75;\r\n\r\n    constructor(\r\n        private ipAddress: string,\r\n        private log: ILogProvider,\r\n    ) {\r\n        this.baseUrl = `http://${this.ipAddress}/`;\r\n        this.cgiUrl = `${this.baseUrl}cgi/`;\r\n    }\r\n\r\n    async loginAsync(username: string = 'waterkotte', password: string = 'waterkotte'): Promise<Login> {\r\n        const loginUrl = `${this.cgiUrl}login?username=${username}&password=${password}`;\r\n        const response = await this.requestAsync(loginUrl);\r\n\r\n        const result = String(response.data).matchAll(WaterkotteCgi.LOGIN_REQUEST_REG_EXP).next()?.value?.groups;\r\n\r\n        switch (Number(result?.status)) {\r\n            case 1:\r\n                this.log.debug('Successfully logged in');\r\n                break;\r\n            default:\r\n                if (result) {\r\n                    throw new WaterkotteError(Number(result.status), result.message);\r\n                } else {\r\n                    throw new AdapterError(`Unhandled response from heat pump: ${response.data}`);\r\n                }\r\n        }\r\n\r\n        const cookie = (response.headers['set-cookie'] as string[])\r\n            ?.find((cookie) => cookie.includes(this.cookieName))\r\n            ?.match(new RegExp(`^${this.cookieName}=(.+?);`))?.[1];\r\n\r\n        if (!cookie) {\r\n            throw new AdapterError(\r\n                `Unable to login: Could not find login token '${this.cookieName}' - Response: '${response.data}'`,\r\n            );\r\n        }\r\n\r\n        return <Login>{ token: cookie };\r\n    }\r\n\r\n    async logoutAsync(): Promise<void> {\r\n        const logoutUrl = `${this.cgiUrl}logout`;\r\n        const response = await this.requestAsync(logoutUrl);\r\n\r\n        const result = String(response.data).matchAll(WaterkotteCgi.LOGIN_REQUEST_REG_EXP).next()?.value?.groups;\r\n\r\n        switch (Number(result?.status)) {\r\n            case 1:\r\n                this.log.debug('Successfully logged out');\r\n                break;\r\n            default:\r\n                if (result) {\r\n                    throw new WaterkotteError(Number(result.status), result.message);\r\n                } else {\r\n                    throw new AdapterError(`Unhandled response from heat pump: ${response.data}`);\r\n                }\r\n        }\r\n    }\r\n\r\n    async getTagsAsync(tags: CommonState[], login: Login): Promise<TagResponse[]> {\r\n        const tagResponses: TagResponse[] = [];\r\n\r\n        for (let i = 0; i < tags.length; i += this.maximumTagsPerRequest) {\r\n            const chunk = tags.slice(i, i + this.maximumTagsPerRequest);\r\n            const record = chunk.reduce(\r\n                (acc, item) => ({ ...acc, [item['Id']]: item }),\r\n                {} as Record<string, CommonState>,\r\n            );\r\n\r\n            const tagUrl = `${this.cgiUrl}readTags?n=${chunk.length + chunk.map((x, i) => `&t${i + 1}=${x.Id}`).join('')}`;\r\n            const response = await this.requestAsync(tagUrl, login);\r\n\r\n            for (const match of String(response.data).matchAll(WaterkotteCgi.TAG_RESPONSE_REG_EXP)) {\r\n                const parameter = match.groups;\r\n                if (!parameter) {\r\n                    continue;\r\n                }\r\n\r\n                const ctor = parameter.status != TagResponse.STATUS_OK ? UnknownTagResponse : TagResponse;\r\n\r\n                const state = record[parameter.name];\r\n\r\n                if (!state) {\r\n                    this.log.warn(`Could not match tag resonse for ${parameter.name} to any requested tag`);\r\n                    continue;\r\n                }\r\n\r\n                tagResponses.push(\r\n                    new ctor(\r\n                        {\r\n                            name: parameter.name,\r\n                            value: parameter.value,\r\n                            status: parameter.status,\r\n                            unkown: parameter.unknown,\r\n                        },\r\n                        state,\r\n                    ),\r\n                );\r\n            }\r\n        }\r\n\r\n        return tagResponses;\r\n    }\r\n\r\n    public async requestAsync(url: string, login?: Login): Promise<axios.AxiosResponse<any, any>> {\r\n        try {\r\n            const response = await axios.get(url, {\r\n                headers: { Cookie: login ? `${this.cookieName}=${login.token}` : '' },\r\n            });\r\n\r\n            return response;\r\n        } catch (e: unknown) {\r\n            const baseMessage = `Request ${url.includes('password') ? '' : `to '${url}' `}failed: `;\r\n            if (e instanceof Error) {\r\n                throw new RethrowError(e, `${baseMessage}${e.message}`);\r\n            } else {\r\n                throw new AdapterError(`${baseMessage}${String(e)}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* async writeTags(tags: CommonState[], login: Login): Promise<void> {\r\n        if (tags.length > 75) {\r\n            throw new Error(`Maximum amount of tags per request exceeded (${tags.length}/75)`);\r\n        }\r\n        throw new Error(`Not implemented`);\r\n        const record = tags.reduce((acc, item) => ({ ...acc, [item['Id']]: item }), {} as Record<string, CommonState>);\r\n        var tagUrl =\r\n            baseUrl +\r\n            'writeTags?returnValue=true&n=' +\r\n            tags.length +\r\n            tags.map((x, i) => '&t' + (i + 1) + '=' + x.Id).join('');\r\n        const response = await axios.get(tagUrl, {\r\n            headers: { 'User-Agent': 'ioBroker', Cookie: 'IDALToken=' + login.token },\r\n        });\r\n\r\n        if (response.status === 200) {\r\n            for (let match of String(response.data).matchAll(regex)) {\r\n                const parameter = match.groups;\r\n                console.log(`${parameter.name} ${record[parameter.name].Text} = ${parameter.value}`);\r\n                const state = record[parameter.name];\r\n                setOrCreate(\r\n                    '0_userdata.0.Waterkotte.' + state.Path + '.' + state.Id,\r\n                    state.normalizeValue(parameter.value),\r\n                    true,\r\n                    state.getCommonObject(),\r\n                );\r\n            }\r\n        } else {\r\n            log('Axios Status - Requesting locales: ' + response.state, 'warn');\r\n        }\r\n    }*/\r\n}\r\n"],
  "mappings": "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",
  "names": ["cookie", "i", "axios"]
}
